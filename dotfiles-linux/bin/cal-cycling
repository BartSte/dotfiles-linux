#!/usr/bin/env python

"""
Script to estimate the minimal number of calories burned while cycling. The
assumptions are chosen such that the actual number of calories burned is
greater than the estimate.

Assumptions:
    - Wind speed is 0 m/s, assuming we start and end at the same location thus
    - No drafting behind other cyclists.

A rough check to demonstrate the validity is by comparing it to the following
site:

    - https://www.gribble.org/cycling/power_v_speed.html?units=metric&rp_wr=70&rp_wb=10&rp_a=0.62&rp_cd=0.63&rp_dtl=2&ep_crr=0.003&ep_rho=1.293&ep_g=0&ep_headwind=0&p2v=200&v2p=30

If you fill in the values used in this script, you get the following results for
a 80 kg cyclist + bike that cycles 30 km in 1 hour:

    If you want to ride at groundspeed velocity 30 km/h, you must apply 169.13
    watts of power.

So, in 1 hour, with an efficiency of 0.25, the energy consumption per hour is:

    (169.13 W * 3600 s) / 0.25 = 2435472 J = 582 kcal


If we run the following command:

    cal-cycling 80 30 01:00

results in:

    Average power:                169 W
    Energy consumption cyclist:   581 kcal

Which is close enough.
"""

from argparse import ArgumentParser, Namespace
from dataclasses import dataclass
from datetime import time


@dataclass
class CyclingStatistics:
    """
    Based on the attributes, a set of cycling statistics are calculated and
    presented as properties.

    The "conventional racing bike parameters" of the following study were used:
        - https://www.sheldonbrown.com/rinard/aero/formulas.html

    Attributes
    ----------
        ascend_m: the total ascent in meters
        air_density_kgpm3: the air density in kg/m^3 (default: 1.225)
        cross_sectional_area_m2: the frontal area of the cyclist + bike in m^2
            (default: 0.509)
        distance_m: the distance cycled in meters
        drag_coefficient: the coefficient of drag (default: 0.88)
        gravity: the acceleration due to gravity in m/s^2 (default: 9.81)
        human_efficiency: the efficiency of the human body to convert calories
            to on the pedals of the bike (default: 0.25)
        roll_resistance: the coefficient of roll resistance (default: 0.005)
        time_s: the time taken to cycle the distance in seconds
        weight_kg: the weight of the cyclist + bike in kg

    """

    time: time
    distance_m: float
    weight_kg: float
    ascend_m: float
    descent_m: float

    air_density_kgpm3: float = 1.293
    drag_coefficient_times_area_m2: float = 0.39
    drive_train_efficiency: float = 0.98
    gravity: float = 9.81
    human_efficiency: float = 0.25
    roll_resistance: float = 0.003

    @property
    def summary(self) -> str:
        """
        Return the string representation of the result.

        Returns
        -------
            the string representation of the result

        """
        return "\n".join(
            [
                "Inputs",
                "------",
                f"Time:             {self.time}",
                f"Weight:           {self.weight_kg:.2f} kg",
                f"Distance:         {self.distance_km:.2f} km",
                f"Average speed:    {self.speed_kmph:.2f} km/h",
                "\nResults",
                "-------",
                f"Average power:                {self.avgerage_power_pedals_w:.0f} W",
                f"Work done (no losses):        {self.work_j * 1e-3:.0f} kJ",
                f"Energy consumption cyclist:   {self.kcal_burned:.0f} kcal",
            ]
        )

    @property
    def detailed(self) -> str:
        """
        Return the detailed string representation of the result.

        Returns
        -------
            the detailed string representation of the result

        """
        return "\n".join(
            [
                "Inputs",
                "------",
                f"Time:             {self.time}",
                f"Weight:           {self.weight_kg:.2f} kg",
                f"Distance:         {self.distance_km:.2f} km",
                f"Average speed:    {self.speed_kmph:.2f} km/h",
                "\nResults",
                "-------",
                f"Average power:                {self.avgerage_power_pedals_w:.0f} W",
                f"Work done (no losses):        {self.work_j * 1e-3:.0f} kJ",
                f"Energy consumption cyclist:   {self.kcal_burned:.0f} kcal",
                "Note that the the work done by the cyclist is smaller than the"
                " energy consumption as the human body is not 100% efficient.",
                "\nConstants",
                "---------",
                f"Air density:              {self.air_density_kgpm3} kg/m^3",
                f"Roll resistance:          {self.roll_resistance}",
                f"Gravity:                  {self.gravity} m/s^2",
                f"Human efficiency:         {self.human_efficiency}",
                f"Drive train efficiency:   {self.drive_train_efficiency}",
                f"Drag coefficient x Area:  {self.drag_coefficient_times_area_m2}",
            ]
        )

    @property
    def json(self) -> str:
        """
        Return the result as a JSON string.

        Returns
        -------
            the result as a JSON string

        """
        return (
            "{"
            f'"time": "{self.time}", '
            f'"weight": {self.weight_kg:.2f}, '
            f'"distance": {self.distance_km:.2f}, '
            f'"average_speed": {self.speed_kmph:.2f}, '
            f'"work_done": {self.work_j:.0f}, '
            f'"power": {self.avgerage_power_pedals_w:.0f}, '
            f'"calories_burned": {self.kcal_burned:.0f}, '
            f'"air_density": {self.air_density_kgpm3}, '
            f'"drag_coefficient_times_area": {self.drag_coefficient_times_area_m2}, '
            f'"roll_resistance": {self.roll_resistance}, '
            f'"gravity": {self.gravity}, '
            f'"human_efficiency": {self.human_efficiency}'
            "}"
        )

    @property
    def time_s(self) -> float:
        """
        Return the time taken to cycle the distance in seconds.

        Returns
        -------
            the time taken to cycle the distance in seconds

        """
        return self.time.hour * 3600 + self.time.minute * 60 + self.time.second

    @property
    def distance_km(self) -> float:
        """
        Return the distance cycled in kilometers.

        Returns
        -------
            the distance cycled in kilometers

        """
        return self.distance_m / 1000

    @property
    def speed_kmph(self) -> float:
        """
        Return the average speed in km/h.

        Returns
        -------
            the average speed in km/h

        """
        return self.distance_km / (self.time_s / 3600)

    @property
    def speed_ms(self) -> float:
        """
        The average speed in m/s.

        Returns
        -------
            the average speed in m/s

        """
        return self.distance_m / self.time_s

    @property
    def avgerage_power_rear_wheel_w(self) -> float:
        """
        Return the power output in watts.

        Returns
        -------
            the power output in watts

        """
        return self.work_j / self.time_s

    @property
    def avgerage_power_pedals_w(self) -> float:
        """
        Return the power output in watts.

        Returns
        -------
            the power output in watts

        """
        return self.work_j / (self.time_s * self.drive_train_efficiency)

    @property
    def work_j(self) -> float:
        """
        Work done (no losses) in joules.

        Returns
        -------
            the work done in joules

        """
        return self._calc_work()

    def _calc_work(
        self,
        efficiency_actuator: float = 1.0,
        efficiency_drive_train: float = 1.0,
    ) -> float:
        """
        Calculate the work that needs to be done in joules.

        3 forces are considered that the cyclist has to overcome:
            - Rolling resistance, created by the tires on the road.
            - Drag, created by the air resistance.
            - Gravity, created by the slope of the road.

        Using these forces, the work that needs to be done in joules is
        calculated.

        In reality, the cyclist and the drive train are not 100% efficient.
        Hence, the energy consumed by the actuator will be greater than the
        energy that is actually supplied to the pedals. This is taken into
        account by the `efficiency_actuator` and the `efficiency_drive_train`
        parameters. The default value is 1, which means that the energy supplied
        by the actuator is equal to the energy supplied on the back wheel of the
        bike.

        In the case of a cyclist, the efficiency is typically around 0.25. Thus,
        the work supplied by the cyclist must be divided by the efficiency to
        get the actual energy needed by the cyclist.

        In the case of the drive train, the efficiency is typically around 0.95.
        This means that 5% of the energy supplied by the cyclist to the pedals
        is lost in the drive train.

        Note that, for an efficiency of 1 and a netto elevation gain of 0, for
        example 100 ascent and 100 descent, the work done for is 0. This is
        because the energy used to ascend is returned when descending. However,
        when an efficiency of 0.25 is used, the work done is greater than 0,
        since the energy used to ascend is greater than the energy returned when
        descending.

        Returns
        -------
            the work that needs to be done in joules

        """
        work_drag: float = (
            self.distance_m * self.force_drag
        ) / efficiency_actuator

        work_ascend: float = (
            self.ascend_m * self.force_gravity
        ) / efficiency_actuator
        work_descend: float = -self.descent_m * self.force_gravity
        work_gravity: float = work_ascend + work_descend

        work_roll: float = (
            self.distance_m * self.force_roll
        ) / efficiency_actuator

        work_pedals: float = work_drag + work_gravity + work_roll

        return work_pedals / efficiency_drive_train

    @property
    def force_drag(self) -> float:
        """
        The drag is calculated by using the drag coefficient times the frontal
        area.


        Returns
        -------
            the drag in N

        """
        return (
            0.5
            * self.drag_coefficient_times_area_m2
            * self.air_density_kgpm3
            * self.speed_ms**2
        )

    @property
    def force_gravity(self) -> float:
        """
        The work done to overcome the gravity is calculated detemined the
        potential energy difference between the start and end of the ride.


        Returns
        -------
            the gravity in N

        """
        return self.weight_kg * self.gravity

    @property
    def force_roll(self) -> float:
        """
        The rolling resistance is calculated by the weight of the cyclist and
        bike times the coefficient of rolling resistance.

        Returns
        -------
            the rolling resistance in N

        """
        return self.force_gravity * self.roll_resistance

    @property
    def kcal_burned(self) -> float:
        """
        Return the number of calories burned in kcal.

        Returns
        -------
            the number of calories burned in kcal

        """
        joules_to_kcal: float = 0.239005736 * 1e-3
        work_j: float = self._calc_work(
            self.human_efficiency, self.drive_train_efficiency
        )
        return work_j * joules_to_kcal


def main() -> str:
    """
    Return cycling statistics based on the cli arguments.

    Returns
    -------
        The cycling statistics based on the cli arguments

    """
    parser: ArgumentParser = make_parser()
    args: Namespace = parser.parse_args()

    result: CyclingStatistics = CyclingStatistics(
        time=args.time,
        distance_m=args.distance_km * 1000,
        weight_kg=args.weight_kg,
        ascend_m=args.ascend_m,
        descent_m=args.descent_m,
    )
    return getattr(result, args.output)


def make_parser() -> ArgumentParser:
    """
    Return the argument parser for the script.

    Returns
    -------
        The argument parser for the script

    """
    parser: ArgumentParser = ArgumentParser(
        description="Estimate the number of calories burned while cycling."
    )
    parser.add_argument(
        "weight_kg",
        action="store",
        type=float,
        help="Weight of the cyclist + bike in kg.",
    )

    parser.add_argument(
        "distance_km", action="store", type=float, help="Distance cycled in km."
    )

    parser.add_argument(
        "time",
        action="store",
        type=parse_time,
        help="Time taken to cycle the distance in iso format, e.g. 01:30:00 for"
        " 1 hour and 30 minutes.",
    )

    parser.add_argument(
        "ascend_m",
        action="store",
        type=float,
        default=0,
        nargs="?",
        help="Total ascent in meters (default: 0).",
    )

    parser.add_argument(
        "descent_m",
        action="store",
        type=float,
        default=0,
        nargs="?",
        help="Total descent in meters (default: 0).",
    )

    parser.add_argument(
        "--output",
        action="store",
        type=str,
        default="summary",
        help="Output format (summary, detailed, json).",
    )

    return parser


def parse_time(time_str: str) -> time:
    """
    Return the time as a time object.

    Parameters
    ----------
        time_str: the time as a string

    Returns
    -------
        the time as a time object

    """
    try:
        return time.fromisoformat(time_str)
    except ValueError as error:
        msg: str = (
            "Time must be in iso format. For example, 01:30:00 is 1 hour and 30"
            " minutes."
        )
        raise ValueError(msg) from error


if __name__ == "__main__":
    print(main())
