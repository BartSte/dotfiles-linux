#!/bin/env bash

usage() {
    cat <<EOF
Usage: wpy [options] <command>

Uses a windows python interpreter in WSL, instead of the one supplied by your
linux distribution. It is assumed that you are running WSL with a mounted
windows drive.

This program checks for the the following environment variables, in order of 
priority:
  - WINVENV: The path to a python virtual environment in windows (e.g. /mnt/c/Users/foo/venv)
  - WINPY: The path to a python interpreter in windows (e.g. /mnt/c/Python/python.exe)

When one of these variables is set, it will be used as the python interpreter.
All arguments passed to wpy are directly passed to the python interpreter. When
one of the options below is passed, no arguments are passed to python.

Options:
  -h, --help      Show this message. No arguments are passed to python anymore.
  --wpy-path      Print the path to the python executable, do not execute
                  any command. No arguments are passed to python anymore.
  --debug         Enable debug output. No arguments are passed to python
                  anymore.

Commands:
    <command>     Command to execute
EOF
}

running_wsl() {
    [[ $(grep -i microsoft /proc/version) ]]
}

get_exe() {
    venv_dir=$1
    echo "Checking for venv directory $venv_dir" >$debug
    [[ -d "$venv_dir" ]] && {
        echo "Using venv $venv_dir" >$debug
        echo "$venv_dir/Scripts/python.exe"
    }
}

if ! running_wsl; then
    echo "Not running WSL" >$debug
    exit 1
fi

path=false
debug=/dev/null
wpy_ops_passed=false
command=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --wpy-path)
            path=true
            wpy_ops_passed=true
            ;;
        --debug)
            debug=/dev/stderr
            wpy_ops_passed=true
            ;;
        -h | --help)
            usage
            wpy_ops_passed=true
            ;;
        *)
            command="$command$1 "
            ;;
    esac
    shift
done
echo "path=$path" >$debug
echo "command=$command" >$debug

if [[ -n $WINVENV ]]; then
    echo "Using WINVENV" >$debug
    exe="$(get_exe "$WINVENV")"
elif [[ -n $WINPY ]]; then
    exe=$WINPY
else
    echo "No python interpreter found" >$debug
fi

echo "exe=$exe" >$debug
if [[ $path == true ]]; then
    echo "Printing path to executable" >$debug
    echo "$exe"
elif [[ $wpy_ops_passed == false ]]; then
    echo "Executing $exe $command" >$debug
    eval "$exe $command"
fi
