#!/usr/bin/env bash

# TODO: rewrite in python or c++ for better performance

usage="Usage: update-blocklist  

Download the URL blocklist into the BLOCKLIST file. Resolve the IPs of the
domains in the blocklist and add them to an ipset named IPSET_NAME. Then add an
iptables rule to drop packets to those IPs.

To avoid rate limiting, the blocklist is resolved in parallel with a number of
jobs (-j). The blocklist may be processed in parts (-p), meaning only that
percentage of *existing mappings* will be re-resolved each run.

By storing domain→IP mappings in a file (-m), we can skip re-resolving domains
unnecessarily:

- New domains (in blocklist but not in mappings) are always resolved.
- Domains no longer in the blocklist are removed from ipset.
- A random N% of *existing* domains are re-resolved on each run.

options:
    -u, --url URL       (Default: https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/porn-only/hosts)
    -o, --output FILE   (Default: /etc/blocked-domains.txt)
    -n, --name NAME     (Default: blocked)
    -j, --jobs N        (Default: 8)
    -p, --part N%       (Default: 100)
    -m, --mappings FILE (Default: /var/cache/blocked-mappings.txt)
    -d, --debug         Only process the first 100 domains for testing.
    -h, --help          Show this help message."

URL="https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/porn-only/hosts"
BLOCKLIST="/etc/blocked-domains.txt"
MAPPINGS="/var/cache/blocked-mappings.txt"
IPSET_NAME="blocked"
JOBS=8
PART=100
DEBUG=false

#-------------------------------------------------------------------------------
# Parse command line options
#-------------------------------------------------------------------------------
while [[ $# -gt 0 ]]; do
    case "$1" in
    -u | --url)
        URL="$2"
        shift 2
        ;;
    -o | --output)
        BLOCKLIST="$2"
        shift 2
        ;;
    -n | --name)
        IPSET_NAME="$2"
        shift 2
        ;;
    -j | --jobs)
        JOBS="$2"
        shift 2
        ;;
    -p | --part)
        PART="$2"
        shift 2
        ;;
    -m | --mappings)
        MAPPINGS="$2"
        shift 2
        ;;
    -d | --debug)
        DEBUG=true
        shift
        ;;
    -h | --help)
        echo "$usage"
        exit 0
        ;;
    *)
        echo "Unknown option: $1" >&2
        echo "$usage" >&2
        exit 1
        ;;
    esac
done

mkdir -p "$(dirname "$MAPPINGS")"
touch "$MAPPINGS"

mkdir -p "$(dirname "$BLOCKLIST")"
touch "$BLOCKLIST"

#-------------------------------------------------------------------------------
# 1. Download the blocklist
#-------------------------------------------------------------------------------
echo "Downloading the blocklist" >&2
curl -sSL "$URL" | awk '/^0\.0\.0\.0/ {print $2}' | sort -u >"$BLOCKLIST"

# Debug mode: only first 100 domains
if [[ "$DEBUG" == "true" ]]; then
    echo "Debug mode: processing only the first 100 domains." >&2
    head -n 100 "$BLOCKLIST" >"$BLOCKLIST.debug"
    mv "$BLOCKLIST.debug" "$BLOCKLIST"
fi

#-------------------------------------------------------------------------------
# 2. Load existing mappings into an associative array old_map
#    Format in $MAPPINGS: each line "domain ip1 ip2 ..."
#-------------------------------------------------------------------------------
echo "Loading existing domain→IP mappings..." >&2
declare -A old_map

if [[ -f "$MAPPINGS" ]]; then
    total_lines="$(wc -l <"$MAPPINGS")"
    line_no=0

    while IFS= read -r line; do
        line_no=$((line_no + 1))
        if ((line_no % 500 == 0)); then
            printf "\rRead %d of %d lines" "$line_no" "$total_lines" >&2
        fi
        [[ -z "$line" || "$line" =~ ^# ]] && continue

        domain="${line%% *}"
        ips="${line#* }"
        [[ "$domain" == "$ips" ]] && ips=""

        old_map["$domain"]="$ips"
    done <"$MAPPINGS"
    echo
fi

#-------------------------------------------------------------------------------
# 3. Read the new blocklist into memory
#-------------------------------------------------------------------------------
echo "Reading blocklist into memory..." >&2
mapfile -t all_domains <"$BLOCKLIST"

declare -a new_domains=()
declare -a existing_domains=()

for domain in "${all_domains[@]}"; do
    if [[ -v old_map["$domain"] ]]; then
        existing_domains+=("$domain")
    else
        new_domains+=("$domain")
    fi
done

# Calculate how many existing domains to re-check (PART%)
recheck_count=0
if [[ "${#existing_domains[@]}" -gt 0 ]]; then
    recheck_count=$((${#existing_domains[@]} * PART / 100))
fi

# Shuffle existing domains and pick random subset for re-check
shuf_existing=($(printf "%s\n" "${existing_domains[@]}" | shuf))
recheck_domains=("${shuf_existing[@]:0:$recheck_count}")

# Domains to actually resolve
resolve_domains=("${new_domains[@]}" "${recheck_domains[@]}")

echo "Total domains in blocklist: ${#all_domains[@]}"
echo "New domains (not in old map): ${#new_domains[@]}"
echo "Existing domains: ${#existing_domains[@]}"
echo "Re-check subset: $recheck_count"

#-------------------------------------------------------------------------------
# 4. Resolve needed domains in parallel
#-------------------------------------------------------------------------------
TMP_RESOLVED="/tmp/blocked-domains-resolved.txt"
rm -f "$TMP_RESOLVED"
touch "$TMP_RESOLVED"

echo "Resolving ${#resolve_domains[@]} domains in parallel..." >&2

printf "%s\n" "${resolve_domains[@]}" |
    parallel --jobs "$JOBS" --bar --eta --no-notice '
      ips=$(dig +short A {} 2>/dev/null \
            | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$" \
            | tr "\n" " ")
      echo "{} $ips"
    ' >>"$TMP_RESOLVED"

#-------------------------------------------------------------------------------
# 5. Build new_map: Start from old_map, then overwrite for newly resolved domains
#-------------------------------------------------------------------------------
echo "Updating in-memory domain→IP mappings..." >&2
declare -A new_map
for d in "${!old_map[@]}"; do
    new_map["$d"]="${old_map[$d]}"
done

while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    domain="${line%% *}"
    ips="${line#* }"
    [[ "$domain" == "$ips" ]] && ips=""
    new_map["$domain"]="$ips"
done <"$TMP_RESOLVED"

#-------------------------------------------------------------------------------
# 6. Create ipset if missing
#-------------------------------------------------------------------------------
ipset create "$IPSET_NAME" hash:ip family inet hashsize 262144 maxelem 2000000 2>/dev/null || true

#-------------------------------------------------------------------------------
# 7. Delta update the ipset
#-------------------------------------------------------------------------------
echo "Applying delta updates to ipset: $IPSET_NAME" >&2

# (a) Remove domains/IPs no longer in blocklist
#     i.e., domain not in all_domains => remove all its IPs
declare -A remove_map
count_no=0
while IFS= read -r line; do
    count_no=$((count_no + 1))
    if ((count_no % 100 == 0)); then
        printf "\rProcessed %d of %d domains" "$count_no" "${#all_domains[@]}" >&2
    fi
    [[ -z "$line" ]] && continue
    domain="${line%% *}"
    ips="${line#* }"
    [[ "$domain" == "$ips" ]] && continue

    # If old domain is not in the new blocklist, remove from ipset. If not,
    # we handle it in the next step
    if ! grep -qx "$domain" "$BLOCKLIST"; then
        remove_map["$domain"]="$ips"
    fi
done <"$MAPPINGS"

echo "${#remove_map[@]} domains will be removed from the ipset" >&2
# Remove entire domain if missing from new blocklist
for domain in "${!remove_map[@]}"; do
    for ip in ${remove_map[$domain]}; do
        ipset del "$IPSET_NAME" "$ip" 2>/dev/null || true
    done
    unset "new_map[$domain]"
done

# (b) For domains that remain in the blocklist, remove any old IPs not in the updated set
#     and add any new IPs that weren't previously there
#
# We can compare old_map vs. new_map for the same domain
echo "Removing outdated IPs and adding new ones for changed domains..." >&2
for domain in "${all_domains[@]}"; do
    old_ips="${old_map[$domain]:-}"
    new_ips="${new_map[$domain]:-}"

    # If domain has no new IPs, skip
    [[ -z "$new_ips" ]] && continue

    # Turn them into arrays
    IFS=' ' read -r -a old_ip_array <<<"$old_ips"
    IFS=' ' read -r -a new_ip_array <<<"$new_ips"

    # Build sets for easy membership checks
    declare -A old_set=()
    for ip in "${old_ip_array[@]}"; do
        old_set["$ip"]=1
    done

    declare -A new_set=()
    for ip in "${new_ip_array[@]}"; do
        new_set["$ip"]=1
    done

    # Remove any IPs in old_map that are no longer in new_map
    for ip in "${old_ip_array[@]}"; do
        if [[ -n "$ip" && ! -v new_set["$ip"] ]]; then
            ipset del "$IPSET_NAME" "$ip" 2>/dev/null || true
        fi
    done

    # Add any new IPs that weren't in old_map
    for ip in "${new_ip_array[@]}"; do
        if [[ -n "$ip" && ! -v old_set["$ip"] ]]; then
            ipset add "$IPSET_NAME" "$ip" -exist
        fi
    done
done

# (c) For any domain that is new (not in old_map at all), we might not have handled above
#     but we actually did because new_map already has them. This step is optional
#     since we already add new IPs in the loop. If needed, you can handle purely new domains here.

#-------------------------------------------------------------------------------
# 8. Write new_map to $MAPPINGS
#-------------------------------------------------------------------------------
echo "Writing updated domain→IP mappings to $MAPPINGS" >&2
rm -f "$MAPPINGS"
for domain in "${!new_map[@]}"; do
    echo "$domain ${new_map[$domain]}" >>"$MAPPINGS"
done

#-------------------------------------------------------------------------------
# 9. Ensure iptables rule
#-------------------------------------------------------------------------------
echo "Adding iptables rule if missing..." >&2
iptables -C OUTPUT -m set --match-set "$IPSET_NAME" dst -j DROP 2>/dev/null ||
    iptables -A OUTPUT -m set --match-set "$IPSET_NAME" dst -j DROP

echo "Done. Total domains: ${#all_domains[@]}, new domains: ${#new_domains[@]}, re-checked: $recheck_count" >&2
